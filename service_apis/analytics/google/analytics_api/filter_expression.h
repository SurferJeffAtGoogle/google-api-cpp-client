// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// This code was generated by google-apis-code-generator 1.5.1

// ----------------------------------------------------------------------------
// NOTE: This file is generated from Google APIs Discovery Service.
// Service:
//   Google Analytics API (analytics/v3)
// Generated from:
//   Version: v3
//   Revision: 20170807
// Generated by:
//    Tool: google-apis-code-generator 1.5.1
//     C++: 0.1.5
#ifndef  GOOGLE_ANALYTICS_API_FILTER_EXPRESSION_H_
#define  GOOGLE_ANALYTICS_API_FILTER_EXPRESSION_H_

#include <string>
#include "googleapis/base/integral_types.h"
#include "googleapis/base/macros.h"
#include "googleapis/client/data/jsoncpp_data.h"
#include "googleapis/strings/stringpiece.h"

namespace Json {
class Value;
}  // namespace Json

namespace google_analytics_api {
using namespace googleapis;

/**
 * JSON template for an Analytics filter expression.
 *
 * @ingroup DataObject
 */
class FilterExpression : public client::JsonCppData {
 public:
  /**
   * Creates a new default instance.
   *
   * @return Ownership is passed back to the caller.
   */
  static FilterExpression* New();

  /**
   * Standard constructor for an immutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit FilterExpression(const Json::Value& storage);

  /**
   * Standard constructor for a mutable data object instance.
   *
   * @param[in] storage  The underlying data storage for this instance.
   */
  explicit FilterExpression(Json::Value* storage);

  /**
   * Standard destructor.
   */
  virtual ~FilterExpression();

  /**
   * Returns a string denoting the type of this data object.
   *
   * @return <code>google_analytics_api::FilterExpression</code>
   */
  const char* GetTypeName() const {
    return "google_analytics_api::FilterExpression";
  }

  /**
   * Determine if the '<code>caseSensitive</code>' attribute was set.
   *
   * @return true if the '<code>caseSensitive</code>' attribute was set.
   */
  bool has_case_sensitive() const {
    return Storage().isMember("caseSensitive");
  }

  /**
   * Clears the '<code>caseSensitive</code>' attribute.
   */
  void clear_case_sensitive() {
    MutableStorage()->removeMember("caseSensitive");
  }


  /**
   * Get the value of the '<code>caseSensitive</code>' attribute.
   */
  bool get_case_sensitive() const {
    const Json::Value& storage = Storage("caseSensitive");
    return client::JsonValueToCppValueHelper<bool >(storage);
  }

  /**
   * Change the '<code>caseSensitive</code>' attribute.
   *
   * Determines if the filter is case sensitive.
   *
   * @param[in] value The new value.
   */
  void set_case_sensitive(bool value) {
    client::SetJsonValueFromCppValueHelper<bool >(
      value, MutableStorage("caseSensitive"));
  }

  /**
   * Determine if the '<code>expressionValue</code>' attribute was set.
   *
   * @return true if the '<code>expressionValue</code>' attribute was set.
   */
  bool has_expression_value() const {
    return Storage().isMember("expressionValue");
  }

  /**
   * Clears the '<code>expressionValue</code>' attribute.
   */
  void clear_expression_value() {
    MutableStorage()->removeMember("expressionValue");
  }


  /**
   * Get the value of the '<code>expressionValue</code>' attribute.
   */
  const StringPiece get_expression_value() const {
    const Json::Value& v = Storage("expressionValue");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>expressionValue</code>' attribute.
   *
   * Filter expression value.
   *
   * @param[in] value The new value.
   */
  void set_expression_value(const StringPiece& value) {
    *MutableStorage("expressionValue") = value.data();
  }

  /**
   * Determine if the '<code>field</code>' attribute was set.
   *
   * @return true if the '<code>field</code>' attribute was set.
   */
  bool has_field() const {
    return Storage().isMember("field");
  }

  /**
   * Clears the '<code>field</code>' attribute.
   */
  void clear_field() {
    MutableStorage()->removeMember("field");
  }


  /**
   * Get the value of the '<code>field</code>' attribute.
   */
  const StringPiece get_field() const {
    const Json::Value& v = Storage("field");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>field</code>' attribute.
   *
   * Field to filter. Possible values:
   * - Content and Traffic
   * - PAGE_REQUEST_URI,
   * - PAGE_HOSTNAME,
   * - PAGE_TITLE,
   * - REFERRAL,
   * - COST_DATA_URI (Campaign target URL),
   * - HIT_TYPE,
   * - INTERNAL_SEARCH_TERM,
   * - INTERNAL_SEARCH_TYPE,
   * - SOURCE_PROPERTY_TRACKING_ID,
   * - Campaign or AdGroup
   * - CAMPAIGN_SOURCE,
   * - CAMPAIGN_MEDIUM,
   * - CAMPAIGN_NAME,
   * - CAMPAIGN_AD_GROUP,
   * - CAMPAIGN_TERM,
   * - CAMPAIGN_CONTENT,
   * - CAMPAIGN_CODE,
   * - CAMPAIGN_REFERRAL_PATH,
   * - E-Commerce
   * - TRANSACTION_COUNTRY,
   * - TRANSACTION_REGION,
   * - TRANSACTION_CITY,
   * - TRANSACTION_AFFILIATION (Store or order location),
   * - ITEM_NAME,
   * - ITEM_CODE,
   * - ITEM_VARIATION,
   * - TRANSACTION_ID,
   * - TRANSACTION_CURRENCY_CODE,
   * - PRODUCT_ACTION_TYPE,
   * - Audience/Users
   * - BROWSER,
   * - BROWSER_VERSION,
   * - BROWSER_SIZE,
   * - PLATFORM,
   * - PLATFORM_VERSION,
   * - LANGUAGE,
   * - SCREEN_RESOLUTION,
   * - SCREEN_COLORS,
   * - JAVA_ENABLED (Boolean Field),
   * - FLASH_VERSION,
   * - GEO_SPEED (Connection speed),
   * - VISITOR_TYPE,
   * - GEO_ORGANIZATION (ISP organization),
   * - GEO_DOMAIN,
   * - GEO_IP_ADDRESS,
   * - GEO_IP_VERSION,
   * - Location
   * - GEO_COUNTRY,
   * - GEO_REGION,
   * - GEO_CITY,
   * - Event
   * - EVENT_CATEGORY,
   * - EVENT_ACTION,
   * - EVENT_LABEL,
   * - Other
   * - CUSTOM_FIELD_1,
   * - CUSTOM_FIELD_2,
   * - USER_DEFINED_VALUE,
   * - Application
   * - APP_ID,
   * - APP_INSTALLER_ID,
   * - APP_NAME,
   * - APP_VERSION,
   * - SCREEN,
   * - IS_APP (Boolean Field),
   * - IS_FATAL_EXCEPTION (Boolean Field),
   * - EXCEPTION_DESCRIPTION,
   * - Mobile device
   * - IS_MOBILE (Boolean Field, Deprecated. Use DEVICE_CATEGORY=mobile),
   * - IS_TABLET (Boolean Field, Deprecated. Use DEVICE_CATEGORY=tablet),
   * - DEVICE_CATEGORY,
   * - MOBILE_HAS_QWERTY_KEYBOARD (Boolean Field),
   * - MOBILE_HAS_NFC_SUPPORT (Boolean Field),
   * - MOBILE_HAS_CELLULAR_RADIO (Boolean Field),
   * - MOBILE_HAS_WIFI_SUPPORT (Boolean Field),
   * - MOBILE_BRAND_NAME,
   * - MOBILE_MODEL_NAME,
   * - MOBILE_MARKETING_NAME,
   * - MOBILE_POINTING_METHOD,
   * - Social
   * - SOCIAL_NETWORK,
   * - SOCIAL_ACTION,
   * - SOCIAL_ACTION_TARGET,
   * - Custom dimension
   * - CUSTOM_DIMENSION (See accompanying field index),.
   *
   * @param[in] value The new value.
   */
  void set_field(const StringPiece& value) {
    *MutableStorage("field") = value.data();
  }

  /**
   * Determine if the '<code>fieldIndex</code>' attribute was set.
   *
   * @return true if the '<code>fieldIndex</code>' attribute was set.
   */
  bool has_field_index() const {
    return Storage().isMember("fieldIndex");
  }

  /**
   * Clears the '<code>fieldIndex</code>' attribute.
   */
  void clear_field_index() {
    MutableStorage()->removeMember("fieldIndex");
  }


  /**
   * Get the value of the '<code>fieldIndex</code>' attribute.
   */
  int32 get_field_index() const {
    const Json::Value& storage = Storage("fieldIndex");
    return client::JsonValueToCppValueHelper<int32 >(storage);
  }

  /**
   * Change the '<code>fieldIndex</code>' attribute.
   *
   * The Index of the custom dimension. Set only if the field is a is
   * CUSTOM_DIMENSION.
   *
   * @param[in] value The new value.
   */
  void set_field_index(int32 value) {
    client::SetJsonValueFromCppValueHelper<int32 >(
      value, MutableStorage("fieldIndex"));
  }

  /**
   * Determine if the '<code>kind</code>' attribute was set.
   *
   * @return true if the '<code>kind</code>' attribute was set.
   */
  bool has_kind() const {
    return Storage().isMember("kind");
  }

  /**
   * Clears the '<code>kind</code>' attribute.
   */
  void clear_kind() {
    MutableStorage()->removeMember("kind");
  }


  /**
   * Get the value of the '<code>kind</code>' attribute.
   */
  const StringPiece get_kind() const {
    const Json::Value& v = Storage("kind");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>kind</code>' attribute.
   *
   * Kind value for filter expression.
   *
   * @param[in] value The new value.
   */
  void set_kind(const StringPiece& value) {
    *MutableStorage("kind") = value.data();
  }

  /**
   * Determine if the '<code>matchType</code>' attribute was set.
   *
   * @return true if the '<code>matchType</code>' attribute was set.
   */
  bool has_match_type() const {
    return Storage().isMember("matchType");
  }

  /**
   * Clears the '<code>matchType</code>' attribute.
   */
  void clear_match_type() {
    MutableStorage()->removeMember("matchType");
  }


  /**
   * Get the value of the '<code>matchType</code>' attribute.
   */
  const StringPiece get_match_type() const {
    const Json::Value& v = Storage("matchType");
    if (v == Json::Value::null) return StringPiece("");
    return StringPiece(v.asCString());
  }

  /**
   * Change the '<code>matchType</code>' attribute.
   *
   * Match type for this filter. Possible values are BEGINS_WITH, EQUAL,
   * ENDS_WITH, CONTAINS, or MATCHES. GEO_DOMAIN, GEO_IP_ADDRESS,
   * PAGE_REQUEST_URI, or PAGE_HOSTNAME filters can use any match type; all
   * other filters must use MATCHES.
   *
   * @param[in] value The new value.
   */
  void set_match_type(const StringPiece& value) {
    *MutableStorage("matchType") = value.data();
  }

 private:
  void operator=(const FilterExpression&);
};  // FilterExpression
}  // namespace google_analytics_api
#endif  // GOOGLE_ANALYTICS_API_FILTER_EXPRESSION_H_
